<?php
// Leggi il file di configurazione
$configFilePath = './conf.json';
$configContent = file_get_contents($configFilePath);
$config = json_decode($configContent, true);

// Verifica che il file sia stato caricato correttamente
if ($config === null || !isset($config[0])) {
die("Errore nel caricamento del file di configurazione.");
}

// Estrai le proprietà necessarie dal primo oggetto dell'array
$chatbotConfig = $config[0]; // Ottieni il primo (e unico) oggetto dell'array

// Se la richiesta è di aggiornare i crediti
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
// Verifica se ci sono ancora crediti disponibili
if ($chatbotConfig['credits_count'] > 0) {
// Scala i crediti di 1
$chatbotConfig['credits_count'] -= 1;

// Aggiorna il file di configurazione
$config[0] = $chatbotConfig; // Riporta l'oggetto aggiornato nell'array
file_put_contents($configFilePath, json_encode($config, JSON_PRETTY_PRINT));

// Risposta JSON di successo
echo json_encode(['status' => 'success', 'credits_count' => $chatbotConfig['credits_count']]);
} else {
// Risposta JSON di errore sui crediti insufficienti
echo json_encode(['status' => 'error', 'message' => 'Crediti insufficienti.']);
}
exit; // Esci dopo aver gestito la richiesta POST
}

// Estrai le proprietà necessarie
$backgroundColor = isset($chatbotConfig['background_color']) ? $chatbotConfig['background_color'] : '#ffffff';
$styleColor = isset($chatbotConfig['style_color']) ? $chatbotConfig['style_color'] : '#0000ff';
$textColor = isset($chatbotConfig['text_color']) ? $chatbotConfig['text_color'] : '#000000';
$personaName = $chatbotConfig['persona_name'];
$personaHeading = $chatbotConfig['header'];
$personaId = $chatbotConfig['persona_id'];
$personaKey = $chatbotConfig['persona_apikey'];
$personaImg = (!empty($chatbotConfig['img_url'])) ? $chatbotConfig['img_url'] : 'default.png';


function getFullPath() {
// Ottieni il protocollo HTTP o HTTPS
$protocol =  "https://" ;

// Ottieni il nome del server
$host = $_SERVER['HTTP_HOST'];

// Ottieni il percorso della cartella corrente
$currentPath = rtrim(dirname($_SERVER['PHP_SELF']), '/');

// Combina le parti per formare il percorso completo
$fullPath = $protocol . $host . $currentPath;

return $fullPath;
}

// Verifica se esistono file .txt nella cartella resident_memory
$directory = 'resident_memory';
$files = []; // Array per memorizzare i file trovati
$totalSize = 0; // Variabile per memorizzare la dimensione totale in byte

if (is_dir($directory)) {
// Scansiona la directory per i file .txt
$files = array_filter(scandir($directory), function($file) {
return pathinfo($file, PATHINFO_EXTENSION) === 'txt';
});

// Calcola la dimensione totale dei file
foreach ($files as $file) {
$totalSize += filesize($directory . '/' . $file);
}
}

// Converti la dimensione totale da byte a megabyte
$totalSizeMB = $totalSize / (1024 * 1024); // 1 MB = 1024 * 1024 bytes

$showFileList = !empty($files); // Verifica se ci sono file

// Controllo della dimensione totale dei file
if ($totalSizeMB > 19 && $totalSizeMB < 20) {
echo "<script>alert('Attenzione: sei vicino al limite di spazio (20 MB).');</script>";
} elseif ($totalSizeMB >= 20) {
echo "<script>
document.getElementById('savetodisk').disabled = true;
alert('Limite di dimensione raggiunto. Si prega di cancellare vecchie chat dalla resident memory.');
</script>";
}


?>

<!DOCTYPE html>
<html>
<head>
<title><?php echo $personaName; ?> - <?php echo $personaId; ?></title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta charset="utf-8">
<meta name="Description" CONTENT="">

<style>
* {
margin: 0;
padding: 0;
box-sizing: border-box;
}

body {
background: <?php echo $backgroundColor; ?>;
color: <?php echo $textColor; ?>;
height: 100%;
}
.fixedhead {
background-color: <?php echo $styleColor; ?>;
padding: .5rem 0;        
height: auto;
width: 100%;
display: flex;
border: 1px solid <?php echo $styleColor; ?>;        
flex-direction: column;
align-items: center;        
}   
        
nav {
display: flex;
justify-content: space-between;
align-items: center;
flex-direction: column;
align-items: center;  
height: auto;        
} 
        
nav h2 {
font-size: 1.8rem;
        margin: .5rem auto;
}        
        
.userinput {
  margin: 8px auto;
  background-color: white;
  padding: 10px;
  z-index: 9999;
  width: 100%;
  height: auto;      
  box-shadow: 0 4px 10px <?php echo $styleColor; ?>;
}
nav img {
        display: block;
        width: 48px;
        height: 48px;
        border-radius: 50%;
        box-shadow: 0 2px 8px <?php echo $styleColor; ?>;
        }        

.main {
        width: 100%;
        height: 75%;
        display: flex;
}
.menu {
width: 20%;
height: 100vh;
        padding: 20px 10px;
        border-right: 1px solid black;
}   
      
.fixedwidth {
        width: 100%;
        font-size: .9rem;
        border-radius: 0;
        background-color: <?php echo $styleColor; ?>;
        } 
.menunotice {
        width: 100%;
        font-size: .9rem;
        border-radius: 0;
        background-color: <?php echo $styleColor; ?>;
        text-align: justify;
        border: 1px solid black;
padding: 8px 14px;
margin: 2px 4px; 
        } 
        
#operations {
        width: 100%;
        
        display: flex;
        flex-direction: column;
        justify-content: space-between;
        }  
#feedback {
            font-size: 1rem;
        color: <?php echo $textColor; ?>;
        padding: 4px 6px;
            }     
details {
        margin-bottom: 12px;
        }   
summary {
        padding: 4px;
        } 
        
.preloader {
  width: 48px;
}         

#resmem {
display: block;        
/* background-color: <?php echo $backgroundColor; ?>;
color: <?php echo $textColor; ?>;
cursor: pointer;
width: 100%;        
padding: 8px 14px;
margin: 2px 4px;        
font-size: 1rem;
border-radius: 8px;
border: 1px solid black; */
        
} 
        
#resmem ul {
        background-color: <?php echo $styleColor; ?>;
        padding: 8px 2px;
        margin-left: 1rem;
        }        
        
#resmem ul li {
        cursor: pointer;
        font-size: .9rem;
        color: <?php echo $textColor; ?>;
        }        
        
.menu button {
background-color: <?php echo $styleColor; ?>;
color: <?php echo $textColor; ?>;
cursor: pointer;
width: 100%;        
padding: 8px 14px;
margin: 2px 4px;        
font-size: 1rem;
border-radius: 8px;
border: 1px solid black;
}          
.menu #selectOption {
 background-color: <?php echo $styleColor; ?>;
color: <?php echo $textColor; ?>;
cursor: pointer;
width: 100%;          
padding: 8px 14px;
margin: 2px 4px;        
font-size: 1rem;
border-radius: 8px;
border: 1px solid black;       
}
        
        
.user-message {
background-color: <?php echo $styleColor; ?>;
padding: 10px;
border: 1px solid black;
color: <?php echo $textColor; ?>;
font-size: 1rem;
border-radius: 5px;
margin-bottom: 4px;
}

.chatbot-message {
background-color: <?php echo $styleColor; ?>;
padding: 15px;
color: <?php echo $textColor; ?>;
font-size: 1rem;
border: 1px solid black;
border-radius: 5px;
margin-bottom: 10px;
display: flex;
justify-content: space-between;
align-items: start;
}
        
button {
background-color: <?php echo $styleColor; ?>;
color: <?php echo $textColor; ?>;
cursor: pointer;
padding: 8px 14px;
margin: 2px 4px;        
font-size: 1.2rem;
border-radius: 8px;
border: 1px solid black;
}  
 
.btnShimmer {
        box-shadow: 0 1px 4px <?php echo $textColor; ?>;
        }
.btnShimmer:hover {
        background-color: <?php echo $textColor; ?>;
        color: <?php echo $styleColor; ?>;
        } 

        
.chathistory {
  padding: 10px;
  width: 100%;
  height: 75%;
  overflow-y: auto;
  
}

#chat-container {
height: 100%;
width: 100%;
padding: 10px;
}

footer{
        position: absolute;
        bottom: 20px;
        width: 100%;
display: flex;
        justify-content: center;
        align-items: center;
        font-size: .9rem;
color: black;

}

input {
font-size: 1.2rem;
color: black;
border-radius: 10px;
box-shadow: 0px 4px 10px grey;
padding: 8px;
width: 80%;
margin: 0 auto;
}  
        
.character-image {
        width: 100px;
        height: auto;
        border-radius: 12px;
        }      
        
#user-card-container {
        margin: .25rem auto;
        text-align: center;
        padding: 8px 10px;
        box-shadow: 0 2px 8px black;
        }        
        
</style>
</head>
<body>

<section class="fixedhead">
<nav>
<h2><?php echo $personaName; ?></h2>
<h2><?php echo $personaHeading; ?></h2>        
<img src= "<?php echo $personaImg; ?>">          
</nav>
<div class="userinput">        
<input type="text" id="user-input" placeholder="Type a message..." onkeydown="verifyEnter(event)" />
      
<button onclick="sendMessage()">Send</button>
</div>        
</section>
        
<div class="main">        
<section class="menu">
		<details class="menunotice">
		<summary><h2 style="display: inline-block; cursor: pointer;">TXT Analyzer</h2></summary>
	    <div id="operations">    
	    <form enctype="multipart/form-data" method="POST">
	    <input class="fixedwidth" type="file" accept=".txt" name="file" id="file-input"> 
	    <div id="feedback"></div>
	    <button id="uploadBtn" type="submit">Upload</button>
        <button type="button" class="fixedwidth" onclick="analyzeFile();">Analyze</button>
	    </form>   
	    </div>
		</details>
        <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
        <script>
        $(document).ready(function() {
        $('#uploadBtn').click(function(e) {
        e.preventDefault(); // Previeni il comportamento predefinito del pulsante di submit

        $.ajax({
        url: 'upload.php', // Indirizzo del tuo script PHP
        type: 'POST',
        data: new FormData($('form')[0]),
        processData: false,
        contentType: false,
        success: function (response) {
                    	const data = JSON.parse(response); // Parsing the JSON response
					if (data.status === "success") {
					$('#feedback').html("Your file was uploaded.");
					// Pass the URL of the uploaded image to the analyze function
					$('#operations button[type="button"]').attr('onclick', `analyzeFile("${data.url}");`);
					} else {
					$('#feedback').html(data); // In caso di errori, mostra l'errore
				 }
                }
        });
        });
        });
        </script>
        
		<button id="savetxt">Export Chat</button>   
        <button id="savetodisk">Save in Resident Memory</button>  
		<br>
        <details class="menunotice" id="resmem">
		<summary><h2 style="display: inline-block; cursor: pointer;">Resident Memory</h2></summary>

<ul>
<?php if ($showFileList): ?>
<?php foreach ($files as $file): ?>
<li><span class="file-link" data-file="<?php echo htmlspecialchars($file); ?>"><?php echo htmlspecialchars($file); ?></span></li>
<?php endforeach; ?>
<?php else: ?>
<li>No memory files.</li>
<?php endif; ?>
</ul>
Total file size: <?php echo round($totalSizeMB, 3); ?>/20 MB               
</details>
        <br>
        <details class="menunotice">
		<summary><h2 style="display: inline-block; cursor: pointer;">Persona Details</h2></summary>
         <div id="user-card-container"></div>       
         <script>
document.addEventListener('DOMContentLoaded', function() {
// Carica direttamente il file persona_details.json
fetch('persona_details.json')
.then(response => {
if (!response.ok) {
throw new Error('Network response was not ok ' + response.statusText);
}
return response.json();
})
.then(data => {
const userCardContainer = document.getElementById('user-card-container');

// Controlla se la persona è configurata
if (!data.Persona || data.Persona.length === 0) {
// Messaggio se il file JSON è vuoto
const message = document.createElement('p');
message.innerHTML = 'Your Persona is not set up, please click <a href="persona_setup_basic.html" target="_blank">here</a> to fill the Persona configuration form.';
userCardContainer.appendChild(message);
return; // Esci dalla funzione se non ci sono dati
}

const persona = data.Persona[0];
const userCard = document.createElement('div');
userCard.className = 'character-sheet';

// Header with Name and Image
const header = document.createElement('div');
header.className = 'character-header';

const userImage = document.createElement('img');
userImage.src = persona.Img || 'default-avatar.png';
userImage.className = 'character-image';
header.appendChild(userImage);

const headerText = document.createElement('div');
headerText.className = 'header-text';
const userName = document.createElement('h3');
userName.textContent = `${persona.Name} ${persona.Surname}`;
headerText.appendChild(userName);
const headerPara = document.createElement('p');
headerPara.innerHTML = `Born: ${persona.BirthDay} ${persona.BirthDate}<br>Status: ${persona.MaritalStatus}<br><br>Click <a href="persona_basic_view.html" target="_blank">HERE</a> to load full Persona details.`      
header.appendChild(headerText);
        header.appendChild(headerPara);

userCard.appendChild(header);


userCardContainer.appendChild(userCard);
})
.catch(error => console.error('Error while loading JSON file: ', error));
});
</script>
                
        </details>        

</section>        
        
<section class="chathistory">
<div id="chat-container"></div>
</section>
</div>         


<script>
// Rendere le proprietà disponibili in JavaScript
const config = <?php echo json_encode($chatbotConfig); ?>;

function verifyEnter(event) {
if (event.keyCode === 13) {
event.preventDefault();
sendMessage();
}
}

// Modifica la visibilità del div in base alla presenza dei file
const showFileList = <?php echo json_encode($showFileList); ?>;
if (!showFileList) {
document.getElementById('resmem').style.display = 'none';
}  
        
// Aggiungi evento click a tutti gli elementi con classe file-link
document.querySelectorAll('.file-link').forEach(function(element) {
element.addEventListener('click', function() {
// Ottieni il nome del file selezionato
const filename = this.getAttribute('data-file');

// Carica il contenuto del file tramite AJAX
loadChatContent(filename);
});
});

function loadChatContent(filename) {
const xhr = new XMLHttpRequest();
xhr.open("GET", "resident_memory/" + filename, true);
xhr.onreadystatechange = function () {
if (xhr.readyState === 4 && xhr.status === 200) {
// Imposta il contenuto del chat-container
document.getElementById('chat-container').innerHTML = xhr.responseText;
}
};
xhr.send();
}        
        
//Initialize memory array at each page reload        
let chatMemory = [];        
// Function to create context memory
function createMemory(messages) {
    const memory = [];
    for (const msg of messages) {
        memory.push({ role: msg.role, content: msg.content });
    }
    return memory;
}
        
// Funzione per caricare il file conf.json
async function loadChatbotConfig() {
try {
const response = await fetch('./persona_details.json');
if (!response.ok) { // Controlla se la risposta è OK
throw new Error('Network response was not ok ' + response.statusText);
}
const configData = await response.json();

// Assumi che il file contenga un array e si usi il primo oggetto
const chatbotConfig = configData;

// Inizializza la memoria della chat
chatMemory = createMemory([
{
role: 'system',
content: `You are an AI Persona, meaning a digital reproduction of a fictitious or real character. Your biographical data are: ${JSON.stringify(chatbotConfig)}. If the user asks about yourself, you will answer the requests using your biographical data.`
}
]);

// Accesso e stampa del contenuto
console.log(chatMemory[0].content);

} catch (error) {
console.error('There was a problem with the fetch operation:', error);
}
}

// Chiamata alla funzione per caricare la configurazione
loadChatbotConfig();       
        

// Function to send message
async function sendMessage() {
    const inputElement = document.getElementById('user-input');
    const userInput = inputElement.value.trim();

    if (userInput !== '') {
        showMessage("Guest", userInput);
        chatMemory = await getChatGPTResponse(userInput, chatMemory);
        inputElement.value = '';
    }
        
// Chiamata al server per aggiornare i crediti
try {
const response = await fetch(window.location.href, { // Invia la richiesta allo stesso file PHP
method: 'POST',
headers: {
'Content-Type': 'application/json'
}
});

const data = await response.json();
if (data.status === 'success') {
console.log("Crediti rimanenti:", data.credits_count);
} else {
console.error(data.message);
alert(data.message); // Facoltativo: avvisare l'utente se non ci sono più crediti
}
} catch (error) {
console.error("Errore nella comunicazione con il server:", error);
}        
}

// Function to show message in chat
function showMessage(sender, message) {
    const chatContainer = document.getElementById('chat-container');
    const chatSection = document.querySelector('.chathistory');
    const typingIndicator = document.getElementById('typing-indicator');

    // Remove "Typing in progress..." message when ChatGPT writes the response
    if (typingIndicator && sender !== 'Guest') {
        chatContainer.removeChild(typingIndicator);
    }

    // Create new message element
    const messageElement = document.createElement('div');
    messageElement.innerText = `${sender}: ${message}`;

    // Add correct class depending on sender
    if (sender === 'Guest') {
        messageElement.classList.add('user-message');
    } else {
        messageElement.classList.add('chatbot-message');

        // Add link to copy message content
        const copyLink = document.createElement('button');
        copyLink.classList.add('btnShimmer'); 
        copyLink.innerText = 'Copy';
        copyLink.style.float = 'right';
        copyLink.addEventListener('click', function (event) {
            event.preventDefault();
            const text = message;
            const input = document.createElement('input');
            input.value = text;
            document.body.appendChild(input);
            input.select();
            document.execCommand('copy');
            document.body.removeChild(input);
        });

        messageElement.appendChild(copyLink);
    }

    chatContainer.appendChild(messageElement);
    chatSection.scrollTop = chatSection.scrollHeight;
}

// Function to get ChatGPT response
async function getChatGPTResponse(userInput, chatMemory) {
    const chatContainer = document.getElementById('chat-container');

    const typingIndicator = document.createElement('p');
    typingIndicator.id = 'typing-indicator';
    typingIndicator.innerHTML = '<img src="preloader.gif" class="preloader" alt="Loading...">';
    chatContainer.appendChild(typingIndicator);

    try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
            method: 'POST',
            headers: {
        "Content-Type": "application/json",
        "Authorization": "Bearer <?php echo $personaKey; ?>"
            },
            body: JSON.stringify({
                "model": "gpt-4o-mini",
                "messages": [
                    ...chatMemory,
                    {"role": "user", "content": userInput}
                ]
            })
        });

        if (!response.ok) {
            throw new Error('Invalid API request');
        }

        const data = await response.json();

        if (!data.choices || !data.choices.length || !data.choices[0].message || !data.choices[0].message.content) {
            throw new Error('Invalid API response');
        }

        const chatGPTResponse = data.choices[0].message.content.trim();
        var cleanResponse = chatGPTResponse.replace(/(```html|```css|```javascript|```php|```python)(.*?)/gs, '$2');
        cleanResponse = cleanResponse.replace(/```/g, "");
        showMessage("<?php echo $personaName; ?>", cleanResponse);

        // Add current response to context memory
        chatMemory.push({ role: 'user', content: userInput });
        chatMemory.push({ role: 'assistant', content: cleanResponse });

        // Return updated context memory
        return chatMemory;
    } catch (error) {
        console.error(error);
    }
}


        
// manage file analyzing
async function analyzeFile(url) {
  chatMemory = []; // initializes memory
  try {
    const fileURL = "<?php echo getFullPath(); ?>" + '/' + url;
          console.log(fileURL);
    const response = await fetch(fileURL);
    if (response.ok) {
      const fileContent = await response.text();
      if (fileContent.length <= 15000) { //15000 chars
        console.log(fileContent);
        if (fileContent.length <= 15000) {
          chatMemory = await resetAndAnalyze(fileContent, chatMemory);
        }
      } else {
        alert(
          "The file content is over 15000 chars. The request will be discarded."
                
        );
      }
    } else {
      console.error("Error accessing the content of file: ", fileURL);
    }
  } catch (error) {
    console.error("An error occurred: ", error);
  }
}

async function resetAndAnalyze(fileContent, chatMemory) {
  return await getChatGPTResponseTXT(
    "Summarize this content: " + fileContent,
    chatMemory
  );
}  

// Funzione per ottenere la risposta da ChatGPT sui files di testo
async function getChatGPTResponseTXT(fileContent, chatMemory = []) {
     const chatContainer = document.getElementById('chat-container');    
    const typingIndicator = document.createElement('p');
    typingIndicator.id = 'typing-indicator';
    
    typingIndicator.innerHTML = '<img src="preloader.gif" class="preloader" alt="Loading...">';
    chatContainer.appendChild(typingIndicator);     
try {


response = await fetch('https://api.openai.com/v1/chat/completions', {
method: 'POST',
headers: {
"Content-Type": "application/json",
"Authorization": "Bearer <?php echo $personaKey; ?>"
},
            body: JSON.stringify({
                "model": "gpt-4o-mini",
                "messages": [
...chatMemory.map(item => ({...item})),
{"role": "user", "content": "Summarize this file: " + fileContent}
]

})
});

if (!response.ok) {
throw new Error('Errore in API request');
console.log(response);
}

const data = await response.json();

if (
!data.choices ||
!data.choices.length ||
!data.choices[0].message ||
!data.choices[0].message.content
) {
throw new Error('Invalid API response');
}

const chatGPTResponse = data.choices[0].message.content;

        console.log(chatGPTResponse);
showMessage("<?php echo $personaName; ?>", chatGPTResponse);

        chatMemory.push({ role: 'user', content: fileContent });
        chatMemory.push({ role: 'assistant', content: chatGPTResponse });

        return chatMemory;        
} catch (error) {
console.error(error);

alert('An error occurred during the request. Retry later.');        
}
}
        





// Aggiungi un event listener al bottone "savetxt" per il clic
var saveButtont = document.getElementById('savetxt');
saveButtont.addEventListener('click', handleSaveButtontClick);
        
// Funzione che viene eseguita quando viene fatto clic sul bottone 
function handleSaveButtontClick() {
saveChatContentTxt();
} 
        
// Aggiungi un event listener al bottone "savetxt" per il clic
var saveButtony = document.getElementById('savetodisk');
saveButtony.addEventListener('click', handleSaveButtonyClick);

// Funzione che viene eseguita quando viene fatto clic sul bottone
function handleSaveButtonyClick() {
saveChatResMem();
}        
       
        
function saveChatContentTxt() {
// Ottieni il contenuto del dizionario
var chatContent = document.getElementById('chat-container').innerHTML;

// Rimuovi tutti i tag HTML e aggiungi un nuovo rigo dopo ogni elemento trovato
chatContent = chatContent.replace(/<[^>]+>/g, '\n');

// Genera il nome del file basato sul timestamp attuale
var currentTimestamp = new Date();
var datetime = currentTimestamp.toISOString();

// Rimuovi i caratteri speciali dal nome del file
var filename = 'chatsession_v' + datetime.replace(/[-:.]/g, '');
        
// Sostituisci tutti i < con <
chatContent = chatContent.replace(/&lt;/g, '<');

// Sostituisci tutti i > con >
chatContent = chatContent.replace(/&gt;/g, '>'); 

// Fa in modo che il testo del bottone non compaia nella chat salvata        
chatContent = chatContent.replace('Copy', '');        

// Crea un oggetto Blob per contenere il contenuto del dizionario
var blob = new Blob([chatContent], {type: 'text/plain'});

// Crea un URL oggetto per il blob
var url = URL.createObjectURL(blob);

// Crea un elemento di ancoraggio per il download
var downloadLink = document.createElement('a');
downloadLink.href = url;
downloadLink.download = filename + '.txt';

// Simula il click sull'elemento di ancoraggio per avviare il download
downloadLink.click();

// Rilascia il blob e l'URL oggetto dopo il download
URL.revokeObjectURL(url);
}
     
        
function saveChatResMem() {
// Ottieni il contenuto del dizionario
var chatContent = document.getElementById('chat-container').innerHTML;
// Fa in modo che il bottone non compaia nella chat salvata
chatContent = chatContent.replace(/<button[^>]*>Copy<\/button>/g, '');        
// Genera il nome del file basato sul timestamp attuale
// Genera data e ora in formato 'YYYYMMDD_HHMMSS'
var currentTimestamp = new Date();
var year = currentTimestamp.getUTCFullYear();
var month = String(currentTimestamp.getUTCMonth() + 1).padStart(2, '0'); // Aggiungi 1 al mese
var day = String(currentTimestamp.getUTCDate()).padStart(2, '0');
var hours = String(currentTimestamp.getUTCHours()).padStart(2, '0');
var minutes = String(currentTimestamp.getUTCMinutes()).padStart(2, '0');
var seconds = String(currentTimestamp.getUTCSeconds()).padStart(2, '0');

var datetime = `${year}${month}${day}_${hours}${minutes}${seconds}`;

// Rimuovi i caratteri speciali dal nome del file
var filename = 'memoryfile' + datetime.replace(/[-:.]/g, '');

// Effettua una chiamata AJAX per inviare dati al PHP
var xhr = new XMLHttpRequest();
xhr.open("POST", "save_chat_resmem.php", true);
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

xhr.onreadystatechange = function () {
if (xhr.readyState == 4 && xhr.status == 200) {
alert("Chat salvata con successo!");
}
};

// Invia i dati della chat e il nome del file
xhr.send("content=" + encodeURIComponent(chatContent) + "&filename=" + encodeURIComponent(filename));
}        
        
</script>

</body>
</html>